import { Contract, ContractReceipt as ITransactionReceipt, Event as ITransactionEvent } from 'ethers/contract';
import { Observable } from 'rxjs';
import { Arc } from '../index';
export interface ITransaction {
    contract: Contract;
    method: string;
    args: any[];
    opts?: {
        gasLimit?: number;
        gasPrice?: number;
        value?: number;
        nonce?: number;
    };
}
export { ITransactionReceipt, ITransactionEvent };
export declare enum ITransactionState {
    Sending = 0,
    Sent = 1,
    Mined = 2
}
/**
 * A transaction update is a snapshot of the state of a transaction at a particular time.
 */
export interface ITransactionUpdate<T> {
    state: ITransactionState;
    transactionHash?: string;
    receipt?: ITransactionReceipt;
    /**
     *  number of confirmations
     */
    confirmations?: number;
    /**
     * Parsed return value from the method call
     */
    result?: T;
}
export declare type transactionErrorHandler = (error: Error, transaction: ITransaction, options?: {
    from?: string;
}) => Promise<Error> | Error;
export declare type transactionResultHandler<T> = (receipt: ITransactionReceipt) => T | Promise<T> | undefined;
/**
 * An operation is a stream of transaction updates
 */
export interface IOperationObservable<T> extends Observable<T> {
    send: () => Promise<T>;
}
export declare type Operation<T> = IOperationObservable<ITransactionUpdate<T>>;
/**
 *
 *  * send a transaction to the ethereumblockchain, and return a observable of ITransactionUpdatessend
 * for example:
 *  ```sendTransaction(.....).subscribe((txUpdate) => {
 *    if (txUpdate.state === 'sent' ) { notify("your transaction has been sent, waitin'for it to be mnied") }
 *    if (txUpdate.state === 'mined'} {
 *      notify("your transaction has been mined! It was confirmed ${txUpdate.confirmations} times"}
 *      // and we also ahve the txUpdate.receipt and the txUpdate.result to do stuff with
 *    }
 *  })```
 *
 * @export
 * @template T
 * @param {Arc} context An instance of Arc
 * @param {Transaction} transaction A Web3 transaction object to send
 * @param {TransactionResultHandler<T>} mapReceipt A function that takes the receipt of
 *  the transaction and returns an object
 * @param {TransactionErrorHandler} [errorHandler]
 *  A function that takes an error, and either returns or throws a more informative Error
 *  if errorHander is not provided, a default error handler will throw any errors thrown by calling `transaction.call()`
 * @returns {Operation<T>}
 */
export declare function sendTransaction<T>(context: Arc, tx: ITransaction, mapReceipt: transactionResultHandler<T>, errorHandler: transactionErrorHandler): Operation<T>;
export declare function toIOperationObservable<T>(observable: Observable<T>): IOperationObservable<T>;
export declare function getEvent(receipt: ITransactionReceipt, eventName: string, codeScope: string): ITransactionEvent;
export declare function getEventArgs(receipt: ITransactionReceipt, eventName: string, codeScope: string): any[];
export declare function getEventAndArgs(receipt: ITransactionReceipt, eventName: string, codeScope: string): [ITransactionEvent, any[]];
