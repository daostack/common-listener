import BN from 'bn.js';
import { Contract, Signer } from 'ethers';
import 'ethers/dist/shims';
import { Observable, Observer } from 'rxjs';
import { Address, AnyPlugin, AnyProposal, DAO, Event, GraphNodeObserver, IApolloClientOptions, IApolloQueryOptions, IDAOQueryOptions, IEventQueryOptions, IPFSClient, IPFSProvider, IPluginQueryOptions, IProposalQueryOptions, IRewardQueryOptions, IStakeQueryOptions, ITagQueryOptions, ITransaction, Operation, PluginName, Reward, Stake, Tag, Token, transactionErrorHandler, transactionResultHandler, Web3Client, Web3Provider } from './index';
export declare type IArcOptions = IApolloClientOptions & {
    /** Information about the contracts. Cf. [[setContractInfos]] and [[fetchContractInfos]] */
    contractInfos?: IContractInfo[];
    ipfsProvider?: IPFSProvider;
    web3Provider?: Web3Provider;
    /** determines whether a query should subscribe to updates from the graphProvider. Default is true.  */
    graphqlSubscribeToQueries?: boolean;
};
/**
 * The Arc class holds all configuration.
 * Any useage of the library typically will start with instantiating a new Arc instance
 * @return an instance of Arc
 */
export declare class Arc extends GraphNodeObserver {
    defaultAccount: string | Signer | undefined;
    pendingOperations: Observable<Array<Operation<any>>>;
    ipfsProvider: IPFSProvider;
    ipfs: IPFSClient | undefined;
    get web3Provider(): Web3Provider;
    get web3(): Web3Client | undefined;
    /**
     * a mapping of contrct names to contract addresses
     */
    contractInfos: IContractInfo[];
    observedAccounts: {
        [address: string]: {
            observable?: Observable<BN>;
            observer?: Observer<BN>;
            lastBalance?: string;
            subscriptionsCount: number;
        };
    };
    private _web3Provider;
    private _web3;
    constructor(options: IArcOptions);
    setWeb3(provider: Web3Provider): void;
    getDefaultAddress(): Promise<string | undefined>;
    /**
     * set the contract addresses
     * @param  contractInfos a list of IContractInfo objects
     * @return
     */
    setContractInfos(contractInfos: IContractInfo[]): Promise<void>;
    /**
     * fetch contractInfos from the subgraph
     * @return a list of IContractInfo instances
     */
    fetchContractInfos(apolloQueryOptions?: IApolloQueryOptions): Promise<IContractInfo[]>;
    /**
     * get a DAO instance from an address
     * @param  address address of the dao Avatar
     * @return an instance of a DAO
     */
    dao(address: Address): DAO;
    /**
     * return an observable of the list of DAOs
     * @param options options to pass on to the query
     * @return [description]
     */
    daos(options?: IDAOQueryOptions, apolloQueryOptions?: IApolloQueryOptions): Observable<DAO[]>;
    tags(options?: ITagQueryOptions, apolloQueryOptions?: IApolloQueryOptions): Observable<Tag[]>;
    plugin(id: string, name: PluginName): AnyPlugin;
    plugins(options?: IPluginQueryOptions, apolloQueryOptions?: IApolloQueryOptions): Observable<AnyPlugin[]>;
    proposals(options?: IProposalQueryOptions, apolloQueryOptions?: IApolloQueryOptions): Observable<AnyProposal[]>;
    events(options?: IEventQueryOptions, apolloQueryOptions?: IApolloQueryOptions): Observable<Event[]>;
    rewards(options?: IRewardQueryOptions, apolloQueryOptions?: IApolloQueryOptions): Observable<Reward[]>;
    stakes(options?: IStakeQueryOptions, apolloQueryOptions?: IApolloQueryOptions): Observable<Stake[]>;
    ethBalance(owner: Address): Observable<BN>;
    /**
     * return information about the contract
     * @param  address [description]
     * @return      an IContractInfo instance
     */
    getContractInfo(address: Address): IContractInfo;
    getContractInfoByName(name: string, version: string): IContractInfo;
    getABI(opts: {
        address?: Address;
        abiName?: string;
        version?: string;
    }): any[];
    /**
     * return a web3 Contract instance.
     * @param  address address of the contract to look up in self.contractInfos
     * @param  [abiName] (optional) name of the ABI (i.e. 'Avatar' or 'SchemeRegistrar').
     * @param  [version] (optional) Arc version of contract (https://www.npmjs.com/package/@daostack/arc)
     * @return   a web3 contract instance
     */
    getContract(address: Address, abi?: any[]): Contract;
    /**
     * get the GEN Token
     * @return a Token instance
     */
    GENToken(): Token;
    getAccount(): Observable<Address>;
    setAccount(address: Address): void;
    getSigner(): Observable<Signer>;
    approveForStaking(spender: Address, amount: BN): Operation<undefined>;
    /**
     * How much GEN spender may spend on behalve of the owner
     * @param  owner Address of the owner of the tokens
     * @param  spender Address of the spender
     * @return
     */
    allowance(owner: Address, spender: Address): Observable<BN>;
    /**
     * send an Ethereum transaction
     * @param  transaction  [description]
     * @param  mapToObject  [description]
     * @param  errorHandler [description]
     * @return  An observable of
     */
    sendTransaction<T = undefined>(transaction: ITransaction, mapToObject?: transactionResultHandler<T>, errorHandler?: transactionErrorHandler): Operation<T>;
    /**
     * save data of a proposal to IPFS, return  the IPFS hash
     * @param  options an Object to save. This object must have title, url and desction defined
     * @return  a Promise that resolves in the IPFS Hash where the file is saved
     */
    saveIPFSData(options: {
        title?: string;
        url?: string;
        description?: string;
        tags?: string[];
    }): Promise<string>;
}
export interface IContractInfo {
    id: string;
    version: string;
    address: Address;
    name: string;
}
