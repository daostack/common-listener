import BN from 'bn.js';
import { DocumentNode } from 'graphql';
import { Observable } from 'rxjs';
import { Address, AnyPlugin, AnyProposal, Arc, DAO, Entity, IApolloQueryOptions, ICommonQueryOptions, IEntityRef, IGenesisProtocolParams, IRewardQueryOptions, IStakeQueryOptions, IVoteQueryOptions, Operation, ProposalName, Queue, Reward, Stake, Vote } from '../index';
export declare enum IProposalOutcome {
    None = 0,
    Pass = 1,
    Fail = 2
}
export declare enum IProposalStage {
    ExpiredInQueue = 0,
    Executed = 1,
    Queued = 2,
    PreBoosted = 3,
    Boosted = 4,
    QuietEndingPeriod = 5
}
export declare enum IExecutionState {
    None = 0,
    QueueBarCrossed = 1,
    QueueTimeOut = 2,
    PreBoostedBarCrossed = 3,
    BoostedTimeOut = 4,
    BoostedBarCrossed = 5
}
declare enum ProposalQuerySortOptions {
    resolvesAt = "resolvesAt",
    preBoostedAt = "preBoostedAt"
}
export interface IProposalQueryOptions extends ICommonQueryOptions {
    where?: {
        accountsWithUnclaimedRewards_contains?: Address[];
        active?: boolean;
        boosted?: boolean;
        dao?: Address;
        expiresInQueueAt?: Date | number;
        expiresInQueueAt_gte?: Date | number;
        expiresInQueueAt_lte?: Date | number;
        expiresInQueueAt_gt?: Date | number;
        executedAfter?: Date | number;
        executedBefore?: Date | number;
        id?: string;
        proposer?: Address;
        proposalId?: string;
        stage?: IProposalStage;
        stage_in?: IProposalStage[];
        plugin?: Address;
        orderBy?: ProposalQuerySortOptions;
        type?: ProposalName;
        [key: string]: any | undefined;
    };
}
export interface IProposalBaseCreateOptions {
    dao: Address;
    description?: string;
    descriptionHash?: string;
    title?: string;
    tags?: string[];
    plugin?: Address;
    url?: string;
}
export interface IProposalState {
    id: string;
    dao: IEntityRef<DAO>;
    votingMachine: Address;
    plugin: IEntityRef<AnyPlugin>;
    closingAt: number;
    createdAt: number | Date;
    descriptionHash?: string;
    description?: string;
    name: string;
    executedAt: number;
    organizationId: string;
    paramsHash: string;
    proposal: IEntityRef<AnyProposal>;
    proposer: Address;
    resolvedAt: number;
    tags?: string[];
    title?: string;
    totalRepWhenCreated: BN;
    totalRepWhenExecuted: BN;
    type: ProposalName;
    url?: string;
    votes: Array<IEntityRef<Vote>>;
    votesFor: BN;
    votesAgainst: BN;
    votesCount: number;
    voteOnBehalf: Address;
    winningOutcome: IProposalOutcome;
    queue: IEntityRef<Queue>;
    quietEndingPeriodBeganAt: number;
    stage: IProposalStage;
    accountsWithUnclaimedRewards: Address[];
    boostedAt: number;
    upstakeNeededToPreBoost: BN;
    stakesFor: BN;
    stakesAgainst: BN;
    preBoostedAt: number;
    genesisProtocolParams: IGenesisProtocolParams;
    executionState: IExecutionState;
    expiresInQueueAt: number;
    downStakeNeededToQueue: BN;
    confidenceThreshold: number;
}
export declare abstract class Proposal<TProposalState extends IProposalState> extends Entity<TProposalState> {
    static get baseFragment(): DocumentNode;
    static fragment: {
        name: string;
        fragment: DocumentNode;
    } | undefined;
    static search<TProposalState extends IProposalState>(context: Arc, options?: IProposalQueryOptions, apolloQueryOptions?: IApolloQueryOptions): Observable<Array<Proposal<TProposalState>>>;
    static calculateId(address: Address, proposalCount: number): string;
    protected static itemMapToBaseState<TPlugin extends AnyPlugin, TProposal extends AnyProposal>(context: Arc, item: any, plugin: TPlugin, proposal: TProposal, type: ProposalName): IProposalState | null;
    private static baseFragmentField;
    abstract state(apolloQueryOptions: IApolloQueryOptions): Observable<TProposalState>;
    votingMachine(): Promise<import("ethers").Contract>;
    stakingToken(): import("..").Token;
    stake(outcome: IProposalOutcome, amount: BN): Operation<Stake>;
    votes(options?: IVoteQueryOptions, apolloQueryOptions?: IApolloQueryOptions): Observable<Vote[]>;
    stakes(options?: IStakeQueryOptions, apolloQueryOptions?: IApolloQueryOptions): Observable<Stake[]>;
    rewards(options?: IRewardQueryOptions, apolloQueryOptions?: IApolloQueryOptions): Observable<Reward[]>;
    execute(): Operation<undefined>;
    vote(outcome: IProposalOutcome, amount?: number): Operation<Vote | null>;
}
export {};
